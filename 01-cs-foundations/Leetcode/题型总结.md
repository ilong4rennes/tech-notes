# Graph Search
## BFS
```python
def bfs(g, s):  
  visited = {node: False for node in g}  
  queue = deque()  
  queue.append(s)  
  visited[s] = True  
  while queue:    
	  s = queue.popleft()    
	  for i in g[s]:      
		  if visited[i] is False:        
			  queue.append(i)  
			  visited[i] = True
```

### Level Traversal
```python
def level_order(root):    
	if not root:        
		return []    
	# first level    
	queue = collections.deque([root])  
    results = []    
    # loop to generate next levels    
    while queue:        
	    # save the current level to result        
	    results.append([node.value for node in queue])        
	    # expand to next level        
	    length = len(queue)        
	    for _ in range(length):  
            node = queue.popleft()            
            if node.left:                
	            queue.append(node.left)            
            if node.right:                
	            queue.append(node.right)    
	return results
```

### Connected Components
### Topological Sorting
1. Choose the first node with 0 in-degree B, and remove it
2. Choose the node with 0 in-degree E, and remove it
3. Choose the node with 0 in-degree A, and remove it
4. Choose the node with 0 in-degree C, and remove it
5. Choose the node with 0 in-degree D, and remove it
**In-degree** refers to the number of incoming edges to a node in a directed graph.
![[Pasted image 20241227162204.png]]
Examples:
- linear ordering of nodes in a directed graph
- course schedules
- task scheduler
### Shortest Path
- Step 1: Start with a weighted graph
- Step 2: Choose a starting vertex and assign infinity path values to all other devices
- Step 3: Go to each vertex and update its path length
- Step 4: If the path length of the adjacent vertex is lesser than new path length, don't update it
- Step 5: Avoid updating path lengths of already visited vertices
- Step 6: After each iteration, we pick the unvisited vertex with the least path length. So we choose 5 before 7
- Step 7: Notice how the rightmost vertex has its path length updated twice
- Step 8: Repeat until all the vertices have been visited
- O(E logV)

## DFS
```python
def dfs(g, s):  
  visited = {node: False for node in g}  
  stack = deque()  
  stack.append(s)  
  visited[s] = True  
  while stack:    
	  s = stack.pop()    
	  for i in g[s]:      
		  if visited[i] is False:        
			  stack.append(i)  
			  visited[i] = True
```